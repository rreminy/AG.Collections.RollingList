using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using AG.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics;
using System.ComponentModel;

namespace AG.Collections.Tests
{
    public static class RollingListTests
    {
        public static TheoryData<int, IEnumerable<int>> ItemsSourceWithSize()
        {
            var data = new TheoryData<int, IEnumerable<int>>();
            for (var exp = 0; exp < 3; exp++)
            {
                for (var size = 0; size < 10; size++)
                {
                    for (var count = 0; count < 10; count++)
                    {
                        data.Add(size * (int)Math.Pow(10, exp), Enumerable.Range(0, count * (int)Math.Pow(10, exp)));
                    }
                }
            }
            return data;
        }

        public static TheoryData<int, IEnumerable<int>, int> ItemsSourceWithSizeAndResize()
        {
            var data = new TheoryData<int, IEnumerable<int>, int>();
            for (var newSize = 0; newSize < 10; newSize++)
            {
                for (var size = 0; size < 10; size++)
                {
                    for (var count = 0; count < 10; count++)
                    {
                        data.Add(size, Enumerable.Range(0, count), newSize);
                    }
                }
            }
            return data;
        }

        [Theory(DisplayName = "Adding items")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void CanAddItems(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            Assert.Equal(items.TakeLast(size), list);
        }

        [Theory(DisplayName = "Adding items individually")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void CanAddItemsIndividually(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            foreach (var item in items) list.Add(item);
            Assert.Equal(items.TakeLast(size), list);
        }

        [Theory(DisplayName = "Access and modify items by index")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void CanModifyItems(int size, IEnumerable<int> items)
        {
            if (size == 0) return; // Nothing to test
            var list = new RollingList<int>(size);
            list.AddRange(items);
            if (list.Count == 0) return; // Nothing to test

            var referenceList = items.TakeLast(size).ToList();

            list[0] *= 10;
            referenceList[0] *= 10;
            list[^1] *= 10;
            referenceList[^1] *= 10;

            Assert.Equal(referenceList, list);
        }

        [Theory(DisplayName = "Sequence is correct")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void SequenceIsIncremental(int size, IEnumerable<int> items)
        {
            if (size <= 1) return; // Nothing to test
            var list = new RollingList<int>(size);
            list.AddRange(items);
            if (list.Count <= 1) return; // Nothing to test

            var enumerator = list.GetEnumerator();
            Assert.True(enumerator.MoveNext());

            var last = enumerator.Current;
            var count = 1;
            while (enumerator.MoveNext())
            {
                var current = enumerator.Current;
                Assert.True(current > last); // NOTE: Items generated by our generators are sequential. This may not be true for a real RollingList.
                last = current;
                count++;
            }
            Assert.Equal(list.Count, count);
        }

        [Theory(DisplayName = "Out of range indexes throws")]
        [MemberData(nameof(ItemsSourceWithSize))]
        [SuppressMessage("Major Bug", "S1656", Justification = "Not a bug")]
        public static void IndexOutOfRange(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            Assert.Throws<ArgumentOutOfRangeException>(() => list[-1]);
            Assert.Throws<ArgumentOutOfRangeException>(() => list[list.Count]);

            var referenceList = list.TakeLast(size).ToList();

            foreach (var _ in Enumerable.Range(0, list.Count))
            {
                var index = Random.Shared.Next(int.MinValue, int.MaxValue); // You never know, I want something from [-2]
                if (index >= 0 && index < list.Count)
                {
                    Assert.Equal(referenceList[index], list[index]);
                }
                else
                {
                    Assert.Throws<ArgumentOutOfRangeException>(() => list[index] = list[index]);
                }
            }
        }

        [Theory(DisplayName = "Can resize")]
        [MemberData(nameof(ItemsSourceWithSizeAndResize))]
        public static void Resize(int size, IEnumerable<int> items, int newSize)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            list.Size = newSize;
            Assert.Equal(items.TakeLast(Math.Min(size, newSize)), list);
        }


        [Theory(DisplayName = "Copying to array")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void Copying(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            var listCopy = new int[Math.Min(list.Count, size)];
            list.CopyTo(listCopy, 0);
            var referenceList = items.TakeLast(size).ToList();

            Assert.Equal(referenceList, list);
            Assert.Equal(list, listCopy);
        }

        [Theory(DisplayName = "IndexOf consistency")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void IndexOfConsistency(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            var referenceList = items.TakeLast(size).ToList();

            Assert.Equal(-1, list.IndexOf((int)-3.14));

            foreach (var item in list)
            {
                var expectedIndex = referenceList.IndexOf(item);
                Assert.Equal(expectedIndex, list.IndexOf(item));
                Assert.Equal(item, list[expectedIndex]);
            }

            foreach (var _ in Enumerable.Range(0, list.Count))
            {
                var value = Random.Shared.Next(int.MinValue, int.MaxValue);
                Assert.Equal(referenceList.IndexOf(value), list.IndexOf(value));
            }
        }

        [Theory(DisplayName = "Contains consistency")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void ContainsConsistency(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            var referenceList = items.TakeLast(size).ToList();

            Assert.DoesNotContain((int)-3.14, list);

            foreach (var item in list)
            {
                Assert.Equal(referenceList.Contains(item), list.Contains(item));
            }

            foreach (var _ in Enumerable.Range(0, list.Count))
            {
                var value = Random.Shared.Next(int.MinValue, int.MaxValue);
                Assert.Equal(referenceList.Contains(value), list.Contains(value));
            }
        }

        [Theory(DisplayName = "Clearing")]
        [MemberData(nameof(ItemsSourceWithSize))]
        public static void ClearTest(int size, IEnumerable<int> items)
        {
            var list = new RollingList<int>(size);
            list.AddRange(items);
            list.Clear();
            Assert.Equal(list, Array.Empty<int>());
        }
    }
}
